[
  {
    "objectID": "04-ARIMA.html",
    "href": "04-ARIMA.html",
    "title": "",
    "section": "",
    "text": "本章中，我们首先通过一些模拟分析考察AR模型、MA模型以及ARMA模型的特性，重点验证其自相关系数、偏自相关系数的拖尾或截尾特征。然后以中美汇率为案例，构建一个ARMA模型或ARIMA模型，并检验模型的有效性，最终用于模型预测。\n\n给定一个AR模型形式及其对应的参数，我们可以使用arima.sim 函数方便地生成对应的随机模拟序列。\n其中，arima.sim 函数的主要形式为：arima.sim(n, model = list(ar =, ma =, order =), sd =)\n\nn ：拟合的序列长度\nmodel ：是一个参数列表，其中ar参数为自回归部分的系数向量，如ar = 0.8 ，或ar = c(1, -0.5) ；ma 参数为移动平均部分的系数向量；order = c(p, d, q) ，其中，p 为自回归阶数，d 为差分阶数，默认为0，q 为移动平均阶数。\nsd 为所生成序列的标准差，默认为1\n\n比如，模拟以下四个AR过程：\n(1) \\(x_t=0.8 x_{t-1}+\\varepsilon_t\\)\n(2) \\(x_t=-0.8 x_{t-1}+\\varepsilon_t\\)\n(3) \\(x_t=x_{t-1}-0.5 x_{t-2}+\\varepsilon_t\\)\n(4) \\(x_t=-x_{t-1}-0.5 x_{t-2}+\\varepsilon_t\\)\n\nset.seed(1)\nx1 <- arima.sim(n = 1000, model = list(ar = 0.8))\nx2 <- arima.sim(n = 1000, model = list(ar = -0.8))\nx3 <- arima.sim(n = 1000, model = list(ar = c(1, -0.5)))\nx4 <- arima.sim(n = 1000, model = list(ar = c(-1, -0.5)))\n\n\n\n如果某个中心化AR过程的时序图始终在零附近波动，且其方差没有明显变化的趋势，则该AR过程很有可能是平稳的。\n首先，我们可以使用ts.plot 函数方便地绘制它们：\n\nts.plot(x1)\n\n\n\nts.plot(x2)\n\n\n\nts.plot(x3)\n\n\n\nts.plot(x4)\n\n\n\n\n可以看到，四个序列应该都是平稳的AR过程。\n\n我们也可以使用自相关系数图进行判断。如果某个AR过程的自相关系数的绝对值随着滞后阶数的增加呈指数下降，即拖尾，则该过程一般是平稳的。\n\nacf(x1)\n\n\n\nacf(x2)\n\n\n\nacf(x3)\n\n\n\nacf(x4)\n\n\n\n\n可以看到, 这四个平稳 \\(\\mathrm{AR}\\) 模型, 不论它们是 \\(\\mathrm{AR}(1)\\) 模型还是 \\(\\mathrm{AR}(2)\\) 模 型, 不论它们的特征根是实根还是复根, 是正根还是负根, 它们的自相关系数都呈现出拖尾性和呈指数衰减到零值附近的性质.\n但由于特征根的不同, 它们的自相关系数衰减的方式也不一样. 有的自相关系数 是按负指数单调收敛到零 (如模型 (1)); 有的是呈现正负相间地衰减 (如模型 (2)); 还 有些自回归系数会呈现出类似于周期性的余弦衰减, 即具有 “伪周期” 特征 (如模型 (3)), 这些都是平稳模型自相关系数常见的特征。\n\n\npacf(x1)\n\n\n\npacf(x2)\n\n\n\npacf(x3)\n\n\n\npacf(x4)\n\n\n\n\n可以看出两个 \\(\\mathrm{AR}(1)\\)模型的样本偏自相关系数 1 阶显著不为零, 1 阶之后都近似为零;；而两个 \\(\\mathrm{AR}(2)\\)模型的样本偏自相关系数 2 阶显著不为零, 2 阶之后都近似为零。样 本偏自相关图可以直观地验证 AR 模型偏自相关系数截尾性。\n\n(1) \\(x_t=\\varepsilon_t-2 \\varepsilon_{t-1}\\)\n(2) \\(x_t=\\varepsilon_t-0.5 \\varepsilon_{t-1}\\)\n(3) \\(x_t=\\varepsilon_t-\\frac{4}{5} \\varepsilon_{t-1}+\\frac{16}{25} \\varepsilon_{t-2}\\)\n(4) \\(x_t=\\varepsilon_t-\\frac{5}{4} \\varepsilon_{t-1}+\\frac{25}{16} \\varepsilon_{t-2}\\)\n\nset.seed(1)\nx1 <- arima.sim(n = 1000, model = list(ma = -2))\nx2 <- arima.sim(n = 1000, model = list(ma = -0.5))\nx3 <- arima.sim(n = 1000, model = list(ma = c(-4/5, 16/25)))\nx4 <- arima.sim(n = 1000, model = list(ma = c(-5/4, 25/16)))\nts.plot(x1)\n\n\n\nts.plot(x2)\n\n\n\nts.plot(x3)\n\n\n\nts.plot(x4)\n\n\n\n\n\n\nacf(x1)\n\n\n\nacf(x2)\n\n\n\nacf(x3)\n\n\n\nacf(x4)\n\n\n\n\n可以看到，MA过程的自相关系数是截尾的。其中MA(1)模型自相关系数一阶截尾，MA(2)模型自相关系数二阶截尾。\n\npacf(x1)\n\n\n\npacf(x2)\n\n\n\npacf(x3)\n\n\n\npacf(x4)\n\n\n\n\n相比之下，MA模型的偏自相关系数则拖尾。\n\n\nset.seed(1)\nx <- arima.sim(n = 1000, model = list(ar = 0.5, ma = -0.8))\nts.plot(x)\n\n\n\nacf(x)\n\n\n\npacf(x)\n\n\n\n\n\n\n模型\n自相关系数\n偏自相关系数\n\n\n\nAR(p)\n拖尾\np阶截尾\n\n\nMA(q)\nq阶截尾\n拖尾\n\n\nARMA(p,q)\n拖尾\n拖尾\n\n\n\n\n首先读取中美汇率数据。考虑到2005年左右有相当一段时间中美汇率接近为固定汇率状态，因此我们主要考察2010年以后的数据。\n\nlibrary(bruceR)\n\n\nbruceR (version 0.8.9)\nBRoadly Useful Convenient and Efficient R functions\n\nPackages also loaded:\n√ dplyr         √ emmeans       √ ggplot2\n√ tidyr         √ effectsize    √ ggtext\n√ stringr       √ performance   √ cowplot\n√ forcats       √ lmerTest      √ see\n√ data.table\n\nMain functions of `bruceR`:\ncc()            Describe()  TTEST()\nadd()           Freq()      MANOVA()\n.mean()         Corr()      EMMEANS()\nset.wd()        Alpha()     PROCESS()\nimport()        EFA()       model_summary()\nprint_table()   CFA()       lavaan_summary()\n\nhttps://psychbruce.github.io/bruceR/\n\nNEWS: A new version of bruceR (0.8.10) is available on 2023-03-03!\n***** Please Update *****\ninstall.packages(\"bruceR\", dep=TRUE)\n\nThese R packages are dependencies of `bruceR` but not installed:\npacman, phia, BayesFactor, GGally, GPArotation\n***** Please Install All Dependencies *****\ninstall.packages(\"bruceR\", dep=TRUE)\n\nlibrary(lubridate)\n\n\nAttaching package: 'lubridate'\n\n\nThe following object is masked from 'package:cowplot':\n\n    stamp\n\n\nThe following objects are masked from 'package:data.table':\n\n    hour, isoweek, mday, minute, month, quarter, second, wday, week,\n    yday, year\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\ndata <- import(\"02-01人民币对美元汇率.xlsx\")\n\n√ Successfully imported: 8021 obs. of 2 variables\n\ndata$date <- ymd(data$date)\ndata <- filter(data, date >= ymd(\"2008-1-1\") & date < ymd(\"2021-12-31\"))\nggplot(data, aes(x = date, y = ER)) + geom_line()\n\n\n\n\n\ner <- data$ER\nacf(er)\n\n\n\n\n\n可以看到，中美汇率的自相关系数似乎并未呈现出明显的指数衰减，这意味着该序列很有可能是非平稳的。因此，我们对其进行差分处理，进行平稳时间序列的ARMA建模。\n\nder <- diff(er)\nacf(der)\n\n\n\npacf(der)\n\n\n\n\n可以看到，此时的差分数据der 自相关系数衰减较快，应当是一个平稳时间序列。\n接下来对der 进行随机性检验，发现两个统计量的伴随概率均远小于0.05，拒绝该序列为纯随机序列的原假设，不属于纯随机序列，应当进一步构建ARMA模型。\n\nBox.test(x = der, type = \"Box-Pierce\")\n\n\n    Box-Pierce test\n\ndata:  der\nX-squared = 20.26, df = 1, p-value = 6.761e-06\n\nBox.test(x = der, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  der\nX-squared = 20.278, df = 1, p-value = 6.698e-06\n\n\n\n不过，分别观察自相关系数图和偏自相关系数图，似乎不太容易判断出自相关系数图究竟属于拖尾还是截尾。此处我们也可以看到图示法定阶的问题，有时候我们很难根据自相关系数图和偏自相关系数图确定一个毫无争议的ARMA模型阶数。我们暂时尝试一个ARMA(1,1)模型：\n\nmodel <- arima(x = der, order = c(1, 0, 1))\nprint(model)\n\n\nCall:\narima(x = der, order = c(1, 0, 1))\n\nCoefficients:\n         ar1      ma1  intercept\n      0.9719  -0.9478     -3e-04\ns.e.  0.0136   0.0183      3e-04\n\nsigma^2 estimated as 0.0001186:  log likelihood = 10559.19,  aic = -21110.37\n\n# 使用model$residuals提取出残差，并检验其随机性\nBox.test(model$residuals, type = \"Box-Pierce\")\n\n\n    Box-Pierce test\n\ndata:  model$residuals\nX-squared = 6.7988, df = 1, p-value = 0.009122\n\nBox.test(model$residuals, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  model$residuals\nX-squared = 6.8048, df = 1, p-value = 0.009091\n\n# 使用系数除以系数的标准差，计算对应的t统计量，并使用pt函数计算伴随概率\nt <- model$coef / diag(model$var.coef) ^ 0.5\npt(q = t, df = length(der - length(t)), lower.tail = FALSE)\n\n      ar1       ma1 intercept \n 0.000000  1.000000  0.835541 \n\n\n从残差项的随机性检验可以看到，上述ARMA(1,1)模型的残差仍然不是随机的，说明该模型并未完全提取出der 序列的有用信息。\n\n接下来我们使用auto.arima 函数进行自动定阶和估计。该函数可以使用更为严谨的AIC准则（默认）或其他准则确定模型阶数。\n\nlibrary(zoo)\n\n\nAttaching package: 'zoo'\n\n\nThe following objects are masked from 'package:base':\n\n    as.Date, as.Date.numeric\n\nlibrary(forecast)\n\nRegistered S3 method overwritten by 'quantmod':\n  method            from\n  as.zoo.data.frame zoo \n\nmodel1 <- auto.arima(der) # 默认使用最大似然估计\nprint(model1)\n\nSeries: der \nARIMA(2,0,2) with zero mean \n\nCoefficients:\n         ar1     ar2      ma1      ma2\n      0.7200  0.2519  -0.6530  -0.2922\ns.e.  0.3849  0.3742   0.3779   0.3577\n\nsigma^2 = 0.0001185:  log likelihood = 10562.75\nAIC=-21115.51   AICc=-21115.49   BIC=-21084.84\n\nBox.test(model1$residuals, type = \"Box-Pierce\")\n\n\n    Box-Pierce test\n\ndata:  model1$residuals\nX-squared = 0.014123, df = 1, p-value = 0.9054\n\nBox.test(model1$residuals, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  model1$residuals\nX-squared = 0.014135, df = 1, p-value = 0.9054\n\nt1 <- model1$coef / diag(model1$var.coef) ^ 0.5\npt(q = t1, df = length(der - length(t1) - 1), lower.tail = FALSE)\n\n       ar1        ar2        ma1        ma2 \n0.03072753 0.25044622 0.95794525 0.79296124 \n\n\n可以看到，AIC准则认为应当构建一个ARMA(2,2)模型，且此时该模型的残差项是一个纯随机序列（即白噪声），说明ARMA(2,2)模型较好地提取出了der 序列的有用信息，可以用该模型做进一步的预测。\n\n在前面的案例中，我们通过自相关系数图基本确认中美汇率er 不是一个平稳时间序列，因此我们对它的一阶差分序列der 进行了ARMA模型建模，最终的模型形式为ARMA(2,2)模型。接下来，我们尝试直接对er 序列进行建模。此时，我们仍然可以使用arima.auto 函数进行模型构建。\n可以看到，arima.auto 函数建议我们对er 序列构建一个ARIMA(2,1,2)模型，即对er 序列进行一阶差分，然后建立ARMA(2,2)模型。通过对比model1 和model2 的系数可以发现，对er 序列构建的ARIMA(2,1,2)模型和对der 序列构建的ARMA(2,2)模型，其各项系数是完全一致的。\n\nmodel2 <- auto.arima(er)\nprint(model2)\n\nSeries: er \nARIMA(2,1,2) \n\nCoefficients:\n         ar1     ar2      ma1      ma2\n      0.7200  0.2519  -0.6530  -0.2922\ns.e.  0.3849  0.3742   0.3779   0.3577\n\nsigma^2 = 0.0001185:  log likelihood = 10562.75\nAIC=-21115.51   AICc=-21115.49   BIC=-21084.84\n\nBox.test(model2$residuals, type = \"Box-Pierce\")\n\n\n    Box-Pierce test\n\ndata:  model2$residuals\nX-squared = 0.0090914, df = 1, p-value = 0.924\n\nBox.test(model2$residuals, type = \"Ljung-Box\")\n\n\n    Box-Ljung test\n\ndata:  model2$residuals\nX-squared = 0.0090994, df = 1, p-value = 0.924\n\n\n\n可以使用forecast 包中的forecast 函数对前述ARMA(2,2)模型（model1）进行预测：\n\nmodel1.fore <- forecast(model1, h = 5)\nplot(model1.fore)\n\n\n\n\n\n\ndate <- data$date[-1]\ndates <- ymd(c(\"2022-1-1\", \"2022-1-2\", \"2022-1-3\", \"2022-1-4\", \"2022-1-5\"))\nx <- data.frame(date = date, x = as.vector(model1.fore$x))\nmean <- data.frame(date = dates, mean = as.vector(model1.fore$mean))\nlower <- data.frame(date = dates, lower = as.vector(model1.fore$lower[,2]))\nupper <- data.frame(date = dates, upper = as.vector(model1.fore$upper[,2]))\n\nx <- full_join(x, mean, by = \"date\")\nx <- full_join(x, lower, by = \"date\")\nx <- full_join(x, upper, by = \"date\")\n\nx <- filter(x, date >= ymd(\"2021-12-1\"))\ncolnames(x)[-1] <- c(\"real\", \"fore\", \"lower\", \"upper\")\n\nggplot(data=x, aes(x=date)) +\n  geom_ribbon(aes(ymin=lower, ymax=upper), fill=\"grey70\", alpha=0.5) +\n  geom_line(aes(y=real), color=\"black\") +\n  geom_line(aes(y=fore), color=\"red\") +\n  labs(y = \"\") +\n  theme_bw()\n\nWarning: Removed 5 rows containing missing values (`geom_line()`).\n\n\nWarning: Removed 22 rows containing missing values (`geom_line()`)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "本教程主要使用R语言和Rstudio实现应用时间序列分析课程中的相关内容。\nR语言是一门统计学家常用的编程语言，RStudio是一款强大的集成开发环境（IDE），专门为R编程语言而设计。它提供了许多方便的功能，使得R编程更加高效、快捷和易于管理。\nRStudio包括许多有用的功能，例如：\n\n语法高亮和代码自动补全\n快速导航和搜索\n可交互的图形界面和数据可视化\n常用包的自动安装和管理\n版本控制和项目管理\n集成式的调试工具和错误跟踪\n\n本课程主要参考书目是《应用时间序列分析（第5版）》（易丹辉和王燕 编著），该书主要使用SAS软件完成时间序列分析的相关操作，其中，SAS（Statistical Analysis System）是一种广泛使用的统计分析软件，由SAS Institute公司开发和维护。SAS提供了一系列用于数据管理、数据分析和报告生成的工具和功能，适用于各种不同的数据分析场景。\n不过，相比于SAS，R语言及Rstudio有如下优势：\n\n开源和免费：RStudio是一个免费的开源软件，任何人都可以自由地下载和使用。相比之下，SAS是一个商业软件，需要付费购买和许可证才能使用。\n大量的社区支持和资源：R语言有一个庞大的社区和用户群体，这意味着有大量的资源和支持可用于帮助用户解决问题、学习新技能和分享经验。相比之下，SAS的社区相对较小。\n高度可定制化：RStudio提供了许多插件和扩展，使得用户可以轻松地自定义和定制他们的开发环境。相比之下，SAS的定制化功能有限。\n灵活性：RStudio是一个灵活的工具，适用于多种数据分析任务和技术。它可以与许多其他工具和技术（如Python和SQL等）集成使用，可以处理各种数据类型和格式，也支持各种图形和可视化方式。\n学习曲线较低：RStudio的学习曲线相对较低，因为R语言语法相对较简单，并且RStudio提供了许多可视化和交互式工具，使得用户可以快速地学习和使用。\n\nRstudio开源、小巧、庞大的社区生态等特点，使我们不再需要付费、甚至去实验室，就能够很方便地在个人计算机上处理很多复杂的数据分析工作。因此，本门课程中，我们采用R语言和Rstudio作为主要的程序语言。"
  },
  {
    "objectID": "01-Rstudio.html",
    "href": "01-Rstudio.html",
    "title": "",
    "section": "",
    "text": "第一步：打开R语言官方网站（https://www.r-project.org/）。如果你是第一次安装R语言，直接点击download R 即可。\n\n第二步，点击download R 后，R网站会提示你选择一个合适的镜像。R镜像是一个R软件源的副本，它可以提供更快速的软件包下载速度。我们可以选择一些国内的镜像。比如，你可以选择TUAN Team, Tsinghua University ，即清华大学 对应的镜像，点击对应的链接即可。\n\n第三步，打开清华大学 镜像后，网站会跳转到R语言下载界面。R提供了Linux安装程序、MacOS安装程序和Windows安装程序。你可以根据自己的计算机系统选择适当的安装程序。我的个人计算机是Windows系统，后续以Windows安装程序的下载、安装为例。\n\n第四步，点击Download R for Windows ，进入如下页面：\n\n第五步，点击install R for the first time ，进入如下页面：\n\n第六步，点击Download R-4.2.2 for Windows ，开始下载R语言安装程序。目前的版本为R-4.2.2，文件名为R-4.2.2-win.exe，大小约为76M，相比Matlab、SAS等其他大型统计软件而言，R语言是比较小巧的。\n\n第七步，下载完成后，双击R-4.2.2-win.exe 打开R语言安装程序，系统中会出现如下界面：\n\n第八步，选择适当的语言（如中文简体），点击确定：\n\n第九步，点击下一步 ：\n\n第十步，选择你的安装路径。如果你觉得安装在C盘太占用空间，也可以安装在其他盘。\n\n第十一步，点击下一步：\n\n第十二步，选择no ，并点击下一步：\n\n第十三步，可以保持默认选择，包括创建桌面快捷方式、版本信息保存于注册表内、把R程序同.RData关联起来，并点击下一步。此后，R就会开始自动安装完成。\n\n\n\n\nR语言安装完成后，桌面就会出现R 4.2.2 图标，双击打开，尽可进入R语言操作界面：\n\n\n可以看到，这个界面是相对比较”复古”和简陋的。如果你在工作或学习、科研中经常需要用到R语言处理数据、构建计量模型等，那么不建议使用R语言自身的操作界面，而是用更加美观、便捷的Rstudio。\n\n\n\n第一步，进入Rstudio官网（目前已更名为posit），网址为https://posit.co/：\n\n第二步，点击右上角的DOWNLOAD RSTUDIO ，进入Rstudio下载界面：\n\n第三步，再次点击Rstudio Desktop 子页面中的DOWNLOAD RSTUDIO 按钮，进入如下界面：\n\n第四步，Windows用户可以直接点击DOWNLOAD RSTUDIO DESKTOP FOR WINDOW 开始下载Rstudio安装程序。其他操作系统的用户可以往下滚动页面，找到适合自己操作系统的安装程序：\n\n第五步，下载完成后，双击下载好的Rstudio安装程序包（本案例中下载到的程序包为RStudio-2022.12.0-353.exe）：\n\n第六步，点击下一步，出现如下界面：\n\n第七步，选择安装目录（可以不是C盘）。安装目录选择完成后，点击下一步。请注意，你需要记住你的Rstudio安装目录，因为安装完成后，电脑桌面可能不会自动生成Rstudio快捷启动图标，需要在安装目录中将启动图表发送到桌面快捷方式。\n\n第八步，点击安装，即可安装完成。\n第九步，若桌面没有出现Rstudio快捷启动图表，则进入你的Rstudio安装路径，找到rstudio.exe 文件。比如，我的安装路径是E:\\Rstudio2023a\\RStudio ，那么进入这个文件夹，即可找到该文件：\n\n第十步，鼠标右键单击该文件，并依次选择发送到 ——桌面快捷方式 ，即可在桌面上看到Rstudio的快捷启动图标：\n\n第十一步，如果你觉得.exe 看起来不舒服，也可以给它改个名字，比如rstudio ：\n\n第十二步，双击该图标，即可进入Rstudio操作界面。安装好的Rstudio会自动和你之前安装的R语言软件关联起来。此时打开Rstudio后，其底层的数据计算等都是基于R语言。\n\n\n\n本节部分内容源自《R语言编程——基于tidyverse》，张敬信 著。\n双击桌面的Rstudio快捷启动图标，即可进入Rstudio操作界面：\n\n在使用Rstudio之前，你可以做一些必要的设置，包括：\n\n切换安装扩展包的国内镜像源（目的是为了更快地下载某些程序包）：\n\nTools -> Global Options… -> Packages，点击 Change 修改为，比如北京外国语大学镜像源：\n\n\n设置保存文件的默认编码方式为 UTF-8。Tools -> Global Options… -> code -> Saving，在 Default text encoding 框，点 change，修改为 UTF-8。这样保存出来的各种 R 文件，都将采用 UTF-8 编码，能够尽量避免含有中文的文件在其他电脑上打开乱码。\n\n\n\n建议顺便再勾选 Code -> Display 下的 Rainbow parentheses 框，这样代码中的配对括号将用不同彩虹色匹配。\n另外，还建议设置 General -> Workspace取消勾选 Restore .RData into workspace at startup,并将其下的 save workspace to .RData on exit: 改为 Never. 避免每次打开 RStudio 都加载之前的当前内存数据。\n界面风格设置：Tools -> Global Options… -> Apperance，选择你喜欢的风格。以下是我的Rstudio风格设置："
  },
  {
    "objectID": "02-Rbegin.html",
    "href": "02-Rbegin.html",
    "title": "",
    "section": "",
    "text": "由于本课程不是专门的R语言教学课程，因此我们很难详尽地介绍R语言的所有语法。本节主要根据后续的学习需求，介绍一些常见的、可能会用到的R语言语法。本节部分内容源自https://www.runoob.com/r/r-tutorial.html，感兴趣的同学也可以在该网站中更系统地学习R语言基础语法。\n\nR语言中，你可以把变量 理解成一个名字，它所代表的可以是一个数字、一串字符或是一个矩阵、一个数据框，乃至更加复杂的数据结构。你可以把各种R语言的数据结构赋值给一个变量，方便后续的数据运算。比如，你可以将数字1 赋值给一个叫做a 的变量，然后用print 函数将它展示出来：\n\na <- 1\nprint(a)\n\n[1] 1\n\n\n上述代码中，<- 是R语言中的一个赋值符号，它像一个箭头，表示将右侧的对象赋值给左侧的变量。操作上来讲，<符号和-符号都不是很好打的字符，这会让很多程序员不适应。因此，R 语言的比较新的版本也支持=作为赋值符。\n你也可以将字符好好学习，天天向上！ 赋值给一个叫做b的变量，然后用print 函数将它展示出来。不过，当我们输入字符时，请注意使用英文格式的双引号 ，即\"\" ，否则R语言会报错。\n\nb <- \"好好学习，天天向上！\"\nprint(b)\n\n[1] \"好好学习，天天向上！\"\n\n\n另外，当你运行完上述命令后，Rstudio左上侧的Environment 窗口中会出现我们刚刚赋值过的两个变量：\n\n类似地，你也可以创建一个向量赋值给c ：\n\nc <- 1:9\nprint(c)\n\n[1] 1 2 3 4 5 6 7 8 9\n\n\n其中，1:9 代表从1至9的九个自然数。\n接下来，你也可以将变量c转化成一个矩阵，并赋值给变量d ：\n\nd <- matrix(data = c, nrow = 3, 3)\nprint(d)\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n\n上述代码中，matrix 函数是一个用来生成矩阵的函数。我们使用到了它的三个参数：data 、nrow 和ncol 。其中，data 参数中，我们输入了之前生成的变量c ，也就是1:9；nrow=3 是在告诉R语言我们生成的矩阵为三行；ncol=6 是在告诉R语言我们生成的矩阵为三列。此外，注意变量c 中的数据向矩阵中填充的次序：先自上至下填充完第一列，然后是第二列、第三列，以此类推。\n再来看一下Environment 窗口，出现了一个名为Data 的子窗口，显示我们有一个名为d 的矩阵。你也可以鼠标单击它，直观地看到该矩阵的样子：\n\n\nR 语言的有效的变量名称由字母，数字以及点号. 、下划线_ 等组成，但变量名称不能以数字开头。比如xiaoming123 是一个合格的变量名称，但123xiaoming 则不可以。\n\n我们可以在console窗口中输入单行的命令，然后按回车，即可看到结果：\n\n不过，有时候我们想要实现一些更复杂的功能，并希望这些算法下次还可以重复使用，就需要新建一个R脚本文件。你可以点击如下图表（Rstudio左上角）：\n\n\n然后选择R Script，即可新建一个R脚本文件：\n\n新建R脚本文件后，你可以使用ctrl+s 组合键，将它保存到电脑中的某个文件夹，并给它命名，比如：mycode.R 。这样，当你下次想再使用这份程序时，只需要在文件夹中双击它，即可在Rstudio中打开这份代码。\n\n在新建的R脚本中，如果你想运行某行、某几行或整个脚本的代码，只需要选中想要运行的部分，然后点击上侧的Run 按钮即可。你也可以使用快捷键运行代码，选择要运行的代码行或块，然后按下Ctrl+Enter或Cmd+Enter（在Mac上）。\n\n注释主要用于一段代码的解析，可以让阅读者更易理解，编程语言的注释会被编译器忽略掉，且不会影响代码的执行。\n一般编程语言的注释分为单行注释与多行注释，但是 R 语言只支持单行注释，注释符号为 #。其实如果有多行注释我们只需要在每一行添加#号就好了。\n比如：\n\n# 本行是一个注释\n# 本行也是一个注释\nmyString <- \"Hello, World!\"\n\nprint (myString)\n\n[1] \"Hello, World!\"\n\n\n\n\n下表列出了主要的数学运算符以及他们的运算顺序：\n\n\n优先级\n符号\n含义\n\n\n\n1\n()\n括号\n\n\n2\n^\n乘方运算\n\n\n3\n%%\n整除求余\n\n\n\n%/%\n整除\n\n\n4\n*\n乘法\n\n\n\n/\n除法\n\n\n5\n+\n加法\n\n\n\n-\n减法\n\n\n\n以下实例演示了简单的数学运算：\n\n1 + 2 * 3\n\n[1] 7\n\n(1 + 2) * 3\n\n[1] 9\n\n3 / 4\n\n[1] 0.75\n\n3.4 - 1.2\n\n[1] 2.2\n\n1 - 4 * 0.5 ^ 3\n\n[1] 0.5\n\n8 / 3 %% 2\n\n[1] 8\n\n8 / 4 %% 2\n\n[1] Inf\n\n3 %% 2^2\n\n[1] 3\n\n10 / 3 %/% 2\n\n[1] 10\n\n\n其中，Inf 代表无穷大。\n\n下表列出了R语言支持的关系运算符，关系运算符比较两个向量，将第一向量与第二向量的每个元素进行比较，结果返回一个布尔值（即TRUR 或FALSE ）。\n\n\n\n\n\n\n运算符\n描述\n\n\n\n>\n判断第一个向量的每个元素是否大于第二个向量的相对应元素。\n\n\n<\n判断第一个向量的每个元素是否小于第二个向量的相对应元素。\n\n\n==\n判断第一个向量的每个元素是否等于第二个向量的相对应元素。\n\n\n!=\n判断第一个向量的每个元素是否不等于第二个向量的相对应元素。\n\n\n>=\n判断第一个向量的每个元素是否大于等于第二个向量的相对应元素。\n\n\n<=\n判断第一个向量的每个元素是否小于等于第二个向量的相对应元素。\n\n\n%in%\n用于判断元素是否在向量里，返回布尔值，有的话返回 TRUE，没有返回 FALSE。\n\n\n\n例子：\n\na <- 1\nb <- 2\nv <- c(2, 4, 6, 9)\nt <- c(1, 4, 7, 9)\nprint(v > t)\n\n[1]  TRUE FALSE FALSE FALSE\n\nprint(v < t)\n\n[1] FALSE FALSE  TRUE FALSE\n\nprint(v == t)\n\n[1] FALSE  TRUE FALSE  TRUE\n\nprint(v != t)\n\n[1]  TRUE FALSE  TRUE FALSE\n\nprint(v >= t)\n\n[1]  TRUE  TRUE FALSE  TRUE\n\nprint(v <= t)\n\n[1] FALSE  TRUE  TRUE  TRUE\n\nprint(a %in% t)\n\n[1] TRUE\n\nprint(b %in% t)\n\n[1] FALSE\n\n\n\n\n\n\n\n\n\n运算符\n描述\n\n\n\n&\n且，如果两个元素都为 TRUE，则结果为 TRUE，否则为 FALSE。\n\n\n|\n或，如果两个元素中有一个为 TRUE，则结果为 TRUE，如果都为 FALSE，则返回 FALSE。\n\n\n!\n非，如果元素为 TRUE 则返回 FALSE，如果元素为 FALSE 则返回 TRUE。\n\n\n\n\nTRUE & TRUE\n\n[1] TRUE\n\nTRUE & FALSE\n\n[1] FALSE\n\nFALSE & FALSE\n\n[1] FALSE\n\nTRUE | TRUE\n\n[1] TRUE\n\nTRUE | FALSE\n\n[1] TRUE\n\nFALSE | FALSE\n\n[1] FALSE\n\n!TRUE\n\n[1] FALSE\n\n!FALSE\n\n[1] TRUE\n\n\n\n* 用于两个矩阵时，两个矩阵的维度必须相同，* 试讲两个矩阵中对应的元素两两相乘；\n%*% 则是矩阵乘法，要求第一个矩阵的列数必须和第二个矩阵的行数相同。\n\na1 <- matrix(1:4, 2, 2)\na2 <- matrix(2:5, 2, 2)\nprint(a1)\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nprint(a2)\n\n     [,1] [,2]\n[1,]    2    4\n[2,]    3    5\n\na1 * a2\n\n     [,1] [,2]\n[1,]    2   12\n[2,]    6   20\n\na1 %*% a2\n\n     [,1] [,2]\n[1,]   11   19\n[2,]   16   28\n\n\n其他常见的数学函数（不再一一举例）：\n\n\n函数\n说明\n\n\n\nsqrt(n)\nn的平方根\n\n\nexp(n)\n自然常数e的n次方\n\n\nlog(m,n)\nm的对数函数，返回n的几次方等于m\n\n\nlog(m)\nm的对数函数，底为自然常数e\n\n\nround\n四舍五入\n\n\nceilling\n向上取整\n\n\nfloor\n向下取整\n\n\nsin\n正弦\n\n\ncos\n余弦\n\n\ntan\n正切\n\n\nasin\n反正弦\n\n\nacos\n反余弦\n\n\natan\n反正切\n\n\n\n时间序列分析与概率论密切相关，因此有必要掌握一些常见的分布函数。此处仅介绍与正态分布相关的一些R语言函数：\n\n# 查看标准正态分布中x=0处的概率密度：\ndnorm(0)\n\n[1] 0.3989423\n\n# 查看标准正态分布中x=0处的累积概率，即p(x<=0)\npnorm(0)\n\n[1] 0.5\n\n# 查看累积概率为0.95时的x，即当p(x<=0.95)时，求x\nqnorm(0.95)\n\n[1] 1.644854\n\n# 生成3个均值为5、标准差为2的正态分布随机数\nrnorm(n = 3, mean = 5, sd = 2)\n\n[1] 4.095417 3.094660 3.700137\n\n\n\n下图是R语言的几种比较常见的数据类型：\n\n\n向量（Vector）和矩阵（Matrix）已经在前面有所介绍。数组（Array）可以视为一个更高维度的矩阵。我们知道，矩阵的维度是mn，数组则可以是更高的维度，如n1*n2*n3。\n需要注意的是，向量、矩阵和数组，这三种数据类型中，元素类别必须是相同的。比如，都是数值型，或都是字符型。如果将数字和字符放入一个向量，则数值型会自动转为字符型。比如：\n\na <- c(1, 2, 3, \"b\")\nprint(a)\n\n[1] \"1\" \"2\" \"3\" \"b\"\n\n\nR 语言数组创建使用 array() 函数，该函数使用向量作为输入参数，可以使用 dim 设置数组维度。\narray() 函数语法格式如下：\narray(data = NA, dim = length(data), dimnames = NULL)\n参数说明：\n\ndata 向量，数组元素。\ndim 数组的维度，默认是一维数组。\ndimnames 维度的名称，必须是个列表，默认情况下是不设置名称的。\n\n以下实例我们创建一个 3 行 3 列的的二维数组（即维度为3*3*2）：\n\n# 创建两个不同长度的向量\nvector1 <- 1:18\n\n# 创建数组\nresult <- array(vector1,dim = c(3,3,2))\nprint(result)\n\n, , 1\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n, , 2\n\n     [,1] [,2] [,3]\n[1,]   10   13   16\n[2,]   11   14   17\n[3,]   12   15   18\n\n\n使用 dimnames 参数来设置各个维度的名称：\n\ncolumn.names <- c(\"COL1\",\"COL2\",\"COL3\")\nrow.names <- c(\"ROW1\",\"ROW2\",\"ROW3\")\nmatrix.names <- c(\"Matrix1\",\"Matrix2\")\ndimnames(result) <- list(row.names, column.names, matrix.names)\nprint(result)\n\n, , Matrix1\n\n     COL1 COL2 COL3\nROW1    1    4    7\nROW2    2    5    8\nROW3    3    6    9\n\n, , Matrix2\n\n     COL1 COL2 COL3\nROW1   10   13   16\nROW2   11   14   17\nROW3   12   15   18\n\n\n选择上述数组中第二行、第三列、第一个矩阵中的元素：\n\nresult[2,3,1]\n\n[1] 8\n\n\n选择上述数组中的第二个矩阵：\n\nresult[,,2]\n\n     COL1 COL2 COL3\nROW1   10   13   16\nROW2   11   14   17\nROW3   12   15   18\n\n\n选择上述数组中第二个矩阵，赋值为matrix1，并在matrix1 中选择第一行的数据：\n\nmatrix1 <- result[,,2]\ncol1 <- matrix1[1,]\nprint(col1)\n\nCOL1 COL2 COL3 \n  10   13   16 \n\n\n选择向量col1 中的第一个元素：\n\ncol1[1]\n\nCOL1 \n  10 \n\n\n\n数据框（Data frame）可以理解成我们常说的”表格”。\n数据框是 R 语言的数据结构，是特殊的二维列表。\n数据框每一列都有一个唯一的列名，长度都是相等的，同一列的数据类型需要一致，不同列的数据类型可以不一样。\n\n一般我们从外部（比如excel）读取的数据都会以数据框的形式储存在R语言中。本课程我们不会使用R语言自带的数据框，我们回主要基于R语言的tidyverse 包，使用该包中的tibble 格式的数据框，这种格式可以理解为是data.frame 的进阶版。后续会做进一步介绍。\n以下创建一个简单的数据框，包含姓名、工号、月薪：\n\ntable = data.frame(\n    姓名 = c(\"张三\", \"李四\"),\n    工号 = c(\"001\",\"002\"),\n    月薪 = c(1000, 2000)\n   \n)\nprint(table) # 查看 table 数据\n\n  姓名 工号 月薪\n1 张三  001 1000\n2 李四  002 2000\n\n\n数据框的数据结构可以通过 str() 函数来展示：\n\n# 获取数据结构\nstr(table)\n\n'data.frame':   2 obs. of  3 variables:\n $ 姓名: chr  \"张三\" \"李四\"\n $ 工号: chr  \"001\" \"002\"\n $ 月薪: num  1000 2000\n\n\n我们也可以提取指定的列：\n\n# 提取指定的列\nresult <- data.frame(table$姓名,table$月薪)\nprint(result)\n\n  table.姓名 table.月薪\n1       张三       1000\n2       李四       2000\n\n\n显示前两行：\n\nresult <- table[1:2,]\nprint(result)\n\n  姓名 工号 月薪\n1 张三  001 1000\n2 李四  002 2000\n\n\n我们可以通过类似坐标的形式读取指定行的某一列的数据，以下我们读取第 2 、3 行的第 1 、2 列数据：\n\ntable = data.frame(\n    姓名 = c(\"张三\", \"李四\",\"王五\"),\n    工号 = c(\"001\",\"002\",\"003\"),\n    月薪 = c(1000, 2000,3000)\n)\n# 读取第 2 、3 行的第 1 、2 列数据：\nresult <- table[c(2,3),c(1,2)]\nprint(result)\n\n  姓名 工号\n2 李四  002\n3 王五  003\n\n\n我们可以对已有的数据框进行扩展，以下实例我们添加部门列：\n\ntable = data.frame(\n    姓名 = c(\"张三\", \"李四\",\"王五\"),\n    工号 = c(\"001\",\"002\",\"003\"),\n    月薪 = c(1000, 2000,3000)\n)\n# 添加部门列\ntable$部门 <- c(\"运营\",\"技术\",\"编辑\")\n\nprint(table)\n\n  姓名 工号 月薪 部门\n1 张三  001 1000 运营\n2 李四  002 2000 技术\n3 王五  003 3000 编辑\n\n\n我们可以使用 cbind() 函数将多个向量合成一个数据框：\n\n# 创建向量\nsites <- c(\"Google\",\"Runoob\",\"Taobao\")\nlikes <- c(222,111,123)\nurl <- c(\"www.google.com\",\"www.runoob.com\",\"www.taobao.com\")\n\n# 将向量组合成数据框\naddresses <- cbind(sites,likes,url)\n\n# 查看数据框\nprint(addresses)\n\n     sites    likes url             \n[1,] \"Google\" \"222\" \"www.google.com\"\n[2,] \"Runoob\" \"111\" \"www.runoob.com\"\n[3,] \"Taobao\" \"123\" \"www.taobao.com\"\n\n\n如果要对两个数据框进行合并可以使用 rbind() 函数：\n\ntable = data.frame(\n    姓名 = c(\"张三\", \"李四\",\"王五\"),\n    工号 = c(\"001\",\"002\",\"003\"),\n    月薪 = c(1000, 2000,3000)\n)\nnewtable = data.frame(\n    姓名 = c(\"小明\", \"小白\"),\n    工号 = c(\"101\",\"102\"),\n    月薪 = c(5000, 7000)\n)\n# 合并两个数据框\nresult <- rbind(table,newtable)\nprint(result)\n\n  姓名 工号 月薪\n1 张三  001 1000\n2 李四  002 2000\n3 王五  003 3000\n4 小明  101 5000\n5 小白  102 7000\n\n\n\n列表（List）是 R 语言的对象集合，可以用来保存不同类型的数据，可以是数字、字符串、向量、另一个列表等，当然还可以包含矩阵和函数。\nR 语言创建列表使用 list() 函数。\n如下实例，我们创建一个列表，包含了字符串、向量和数字：\n\nlist_data <- list(\"runoob\", \"google\", c(11,22,33), 123, 51.23, 119.1)\nprint(list_data)\n\n[[1]]\n[1] \"runoob\"\n\n[[2]]\n[1] \"google\"\n\n[[3]]\n[1] 11 22 33\n\n[[4]]\n[1] 123\n\n[[5]]\n[1] 51.23\n\n[[6]]\n[1] 119.1\n\n\n我们可以使用 names()函数给列表的元素命名：\n\n# 给列表元素设置名字\nnames(list_data) <- c(\"name1\", \"name2\", \"data1\", \"number1\", \"number2\", \"number3\")\n\n# 显示列表\nprint(list_data)\n\n$name1\n[1] \"runoob\"\n\n$name2\n[1] \"google\"\n\n$data1\n[1] 11 22 33\n\n$number1\n[1] 123\n\n$number2\n[1] 51.23\n\n$number3\n[1] 119.1\n\n\n列表中的元素可以使用索引来访问，如果使用来 names() 函数命名后，我们还可以使用对应名字来访问：\n\n# 访问列表的第三个元素，返回的仍然是列表类型\nprint(list_data[3])\n\n$data1\n[1] 11 22 33\n\n# 访问列表的第三个元素，返回的是向量\nprint(list_data[[3]])\n\n[1] 11 22 33\n\n# 访问第一个向量元素\nprint(list_data$data1)\n\n[1] 11 22 33\n\n\n\n\n示例：\n\nx <- \"小明\"\nif (is.character(x)){\n  print(\"x是一个字符串\")\n} else {\n  print(\"x不是一个字符串\")\n}\n\n[1] \"x是一个字符串\"\n\n\n其中，is.character 用于判断一个对象是不是字符型。\n\n只要给定的条件为 true，R 语言中的 while 循环语句会重复执行一个目标语句。\n\nv <- 1:5\ni <- 2\n\n# 使用while循环实现一个累加运算\nwhile (i <= 5) {\n   v[i] <- v[i] + v[i-1]\n   i = i + 1\n}\nprint(v)\n\n[1]  1  3  6 10 15\n\n\n上述功能也可以使用cunsum 实现：\n\nv <- 1:5\ncumsum(v)\n\n[1]  1  3  6 10 15\n\n\n\nR 编程语言中 for 循环语句可以重复执行指定语句，重复次数可在 for 语句中控制。\n比如，给定一个向量1:10 ，求每个元素的平方：\n\nv <- 1:10\nfor (i in 1:10){\n  v[i] <- v[i] ^ 2\n}\nprint(v)\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n\n循环语句一般效率比较低下，如果可能的话，尽量使用向量化运算：\n\nv <- 1:10\nprint(v ^ 2)\n\n [1]   1   4   9  16  25  36  49  64  81 100\n\n\n\n\nR包是R语言的扩展程序库，它包含一组已经编写好的函数、数据集、文档和演示程序等资源，以便于R语言用户重复使用和共享。\n使用R包，用户可以快速实现复杂的数据分析、数据可视化和统计建模等任务，而不需要自己编写大量代码。R包是R语言生态系统的重要组成部分，它们是开源的，由R语言社区中的各种贡献者创建和维护，可以通过在线资源库（如CRAN）或者其他渠道获取和安装。同时，用户也可以自己创建和发布R包，从而为R语言生态系统做出自己的贡献。\n\n在R语言中，可以通过以下几种方法来安装R包（以一个名为tidyverse的包为例）：\n\nCRAN镜像安装\n\nCRAN（The Comprehensive R Archive Network）是R语言官方的资源库，其中包含大量的R包和相关资源。要安装一个CRAN中的R包，可以使用以下命令：\n\ninstall.packages(\"tidyverse\")\n\n\nGitHub安装（国内可能有限制，无法访问GitHub）\n\n很多R包也会发布在GitHub上，使用以下命令可以从GitHub上安装一个R包：\n\nlibrary(devtools)\ninstall_github(\"username/package_name\")\n\n其中，username/package_name 是要安装的R包在GitHub上的路径。在使用此方法前，需要先安装devtools 包，可以使用以下命令安装：\n\ninstall.packages(\"devtools\")\n\n\n本地安装\n\n如果已经下载了一个R包的源代码（通常是以.tar.gz 或.zip 格式压缩的文件），可以使用以下命令将其安装到本地：\n\ninstall.packages(\"path_to_package_file\", repos = NULL, type=\"source\")\n\n其中，path_to_package_file是R包的本地文件路径。repos = NULL表示不从远程资源库中下载依赖项，type=\"source\"表示安装的是源代码版本的R包。\n在同一个版本的R语言中，一个包只需要下载一次，后续就可以通过library 函数加载使用它了：\n\nlibrary(tidyverse)\n\n\n有时候，某个R包的开发者可能会提交更新的版本，修复原有的R包中的一些缺陷，或拓展原有R包的功能，此时就需要更新R包。在R语言中，可以使用以下方法来更新已安装的R包：\n\n更新单个包\n\n\nupdate.packages(\"tidyverse\") # 以tidyverse包为例\n\n该命令会检查远程资源库中是否有新版本的R包，如果有，则会下载并安装最新版本的R包。如果没有新版本可用，则不会进行任何操作。\n\n更新所有包\n\n\nupdate.packages()\n\n该命令会检查所有已安装的R包是否有新版本可用，并将所有可更新的R包下载并安装。请注意，更新所有R包可能需要较长时间，取决于R包的数量和大小。\n\n安装R包后，加载R包，就可以使用其中的函数了。\n以ggplot2包为例，该包是一款流行的R语言数据可视化包，它提供了一种基于语法层次结构的绘图系统，可以快速轻松地创建各种类型的高质量图表。\nggplot2基于图形语法，即通过将数据映射到图形属性（例如颜色、大小、形状等）来创建图形。其核心是图层（layer），即不同数据和视觉属性的叠加。通过添加不同的图层和修改各种属性，可以创建各种类型的图表，包括散点图、折线图、条形图、直方图、密度图、箱线图、饼图等等。\n以下是使用ggplot2 绘制散点图的示例：\n\n# 安装ggplot2\n# install.packages(\"ggplot2\") # 本人计算机中已安装，因此此行注释掉\n\n# 加载ggplot2\nlibrary(ggplot2)\n\n# 使用R语言自带的`mtcars`数据集制图：\ndata(mtcars)\nggplot(mtcars, aes(x = wt, y = mpg)) + \n  geom_point()\n\n\n\n\n\n在R中，有几种方法可以寻求帮助，以解决对不熟悉函数的困惑。以下是一些常用的方法：\n\n使用help() 函数\n\n可以使用help 函数来获取函数的帮助信息。例如，如果您想了解mean 函数的用法，可以输入并运行help(mean) ，然后按回车键，将会显示有关该函数的详细帮助信息。\n\nhelp(mean)\n\n\n\n使用example()函数：使用example()函数可以显示有关特定函数的示例。例如，如果您想了解如何使用mean()函数，可以在控制台中输入example(mean)，然后按回车键，将会显示有关该函数的一些示例。\n\n\nexample(mean)\n\n\nmean> x <- c(0:10, 50)\n\nmean> xm <- mean(x)\n\nmean> c(xm, mean(x, trim = 0.10))\n[1] 8.75 5.50\n\n\n\n使用搜索引擎：您可以在互联网上使用搜索引擎（如百度、必应）来搜索特定函数的帮助信息或教程。R社区中也有许多网站和论坛可以寻求帮助，例如Stack Overflow、R-bloggers等等。\n\nR语言的基础函数非常多，随着不断的更新和扩展，基础函数的数量也在不断增加。截至R语言的版本4.0.5，基础函数的数量约为1622个。而这还只是R base中的函数。\n除基础函数外，R语言的众多包则包含了更多函数。以R官方的CRAN为例，截止至2023年3月，CRAN已经收录了19256个可用的包，每个包中又有很多实现特定功能的函数。R包的数量持续以每月100-200个的规模增长。\n因此，要在使用R语言进行数据分析时，了解如何查找、选择和使用适当的R包是非常重要的。而且，由于每个开发者的习惯不同，各种包的函数命名规则、使用方法等也有很大区别。这就需要大家依据自己的数据处理或研究需求寻找对应的R包，并加以学习。有时候，R函数的应用是非常简单的，难点在于背后的统计知识，当你不了解这些统计知识时，再优秀的R包也无济于事。\n本章主要目的是帮助大家初步认识R语言和Rstudio。后续内容中，我们将一边实战，一边学习。对于专注于特定课程学习，仅把R语言作为工具的使用者来说，我相信这是效率更高的做法。"
  },
  {
    "objectID": "03-TSdata.html",
    "href": "03-TSdata.html",
    "title": "",
    "section": "",
    "text": "本章初步认识时间序列数据，并采用R语言完成时间序列数据的生成、外部数据的读取、数据清洗和处理、数据可视化等。\n本章及后续部分通过R语言代码示例，在实现学习目标的同时，向同学们讲解部分新出现的代码是什么含义，即”干中学”。我会尽可能对前文中未出现过的代码做出详细讲解，尽量避免同学们不了解某个命令的功能、用法等。不过，课堂的时间总是有限的，大家有任何不懂之处，课下也可以随时和我交流，学无止境，我们共同进步。\n\n我们教材上已经提到，所谓时间序列，就是按时间顺序排列的一组随机变量。即，\\(\\left\\{X_t, t \\in T\\right\\}\\)。其中，每一个时刻的\\(X_t\\)，都是一个随机变量。\n那么，什么是时间序列的观测值序列呢？可以理解为是时间序列上的某些时间点上的随机变量在特定条件下的实现。比如，中国2000年到2022年的GDP。很显然，我们只在无数个平行时空中的一个时空中，因此我们只能观测到特定的时间序列的观测值。我们用这些观测值\\(\\left\\{x_t\\right\\}\\)来推断随机时间序列的\\(\\left\\{X_t\\right\\}\\)的性质。那么，\\(\\left\\{x_t\\right\\}\\)就是我们在R语言中的主要处理对象。\n\n在R语言中，时间序列数据无非就是一列数据配上特定的时间标签，按顺序存放而已。\n比如，我们可以使用R语言的基础函数ts 来手动构造一个时间序列数据。我们先生成一个随机数据：\n\nx <- rnorm(n = 60, mean = 0, sd = 1)\ny <- cumsum(x)\nprint(y)\n\n [1]  2.6807927  3.2198629  1.8880220  1.3561843  1.5502590  2.1283260\n [7]  3.0086116  4.0676387  3.6742389  3.9826266  4.0909241  2.2344844\n[13]  2.5645446  2.0355648  1.1320198  0.9508380  0.9499048  2.4526133\n[19]  2.9123080  2.4133568  1.0924973  2.5161567  1.4859867  0.9450743\n[25]  0.3136596  1.7296095  3.1432272  3.4537296  4.1846379  4.1314117\n[31]  4.4665872  5.8907781  6.1089378  5.5978975  6.8481324  6.9918361\n[37]  5.7870997  5.1417591  8.0041110  9.6633389 10.0337469  9.1586526\n[43]  7.6334349  7.5920078  6.7871328  5.8723365  6.0932624  5.7393908\n[49]  6.1293975  7.4440225  7.4281986  7.2070010  6.3638391  7.0424320\n[55]  5.7073343  6.0807839  7.2432597  6.7273464  5.4790878  6.7257857\n\n\n上述代码中，我们先用rnorm 函数生成了一个样本量为60，均值为0，标准差为1的相互独立的正态分布随机数（x）。这列随机数也就是白噪声。然后使用cumsum 函数对这列随机数进行了累加运算，得到了一个随机游走序列（y），即：\n\\[\ny_1=x_1, y_2 = x_1 + x_2, y_3 = x_1 + x_2 + x_3，以此类推\n\\]\n很明显，目前y 只是一个向量，因为它没有时间标志。现在我们假设y是一个月度的股票价格数据，时间从2016年1月到2020年12月，共24个月（2年），那么我们可以用ts 函数将其转化为时间序列格式：\n\ny_ts <- ts(data = y, start = 2016, frequency = 12)\nprint(y_ts)\n\n            Jan        Feb        Mar        Apr        May        Jun\n2016  2.6807927  3.2198629  1.8880220  1.3561843  1.5502590  2.1283260\n2017  2.5645446  2.0355648  1.1320198  0.9508380  0.9499048  2.4526133\n2018  0.3136596  1.7296095  3.1432272  3.4537296  4.1846379  4.1314117\n2019  5.7870997  5.1417591  8.0041110  9.6633389 10.0337469  9.1586526\n2020  6.1293975  7.4440225  7.4281986  7.2070010  6.3638391  7.0424320\n            Jul        Aug        Sep        Oct        Nov        Dec\n2016  3.0086116  4.0676387  3.6742389  3.9826266  4.0909241  2.2344844\n2017  2.9123080  2.4133568  1.0924973  2.5161567  1.4859867  0.9450743\n2018  4.4665872  5.8907781  6.1089378  5.5978975  6.8481324  6.9918361\n2019  7.6334349  7.5920078  6.7871328  5.8723365  6.0932624  5.7393908\n2020  5.7073343  6.0807839  7.2432597  6.7273464  5.4790878  6.7257857\n\n\n其中，ts 函数用于将数据向量转化为特定频率的时间序列，data = y 表示所用的向量是y ，即前述生成的随机游走序列；start = 2011 表示数据的起始时间点是2011年；frequency = 12 表示数据频率是12，即月度数据。可以看到，print 后的y_ts 明显有了年度和月份之分。\n那么，转化成时间序列数据有什么用呢？\n\n有些时间序列模型分析的包需要输入的数据对象为时间序列格式，因此转化成R可以识别的时间序列数据后，才可以进行后续的数据分析。当然，也并不一定所有包都有这样的要求，需要看具体的包而定。\n转化成时间序列数据后会比较方便作图。比如，可以直接使用R基础函数plot 函数绘制时序图：\n\n\nplot(y_ts)\n\n\n\n\n相比之下，我们同样用plot 函数绘制未转化成时序数据（y_ts ）的随机游走序列（y），会得到如下图形：\n\nplot(y)\n\n\n\n\n上述时序数据的生成似乎是蛮”鸡肋”的。事实上，除非我们是在做一些模拟实验，一般我们不会在R语言中手动输入数据。对于实证研究者而言，更多情况下，我们是从数据库中下载各类实际的数据，然后将它们导入到R语言中，并进行数据清洗、数据处理、数据分析等工作。这就需要我们掌握一些更实用的时间序列数据处理，或者说通用的数据处理方法。\n接下来，本章将主要解决以下问题：\n\n如何便捷地导入各种格式的外部数据文件（如.xlsx 、.csv 、.txt 等）；\n对于导入的时间序列数据，如何方便地处理日期所在的列，让R语言知道这一列代表的是日期或时间，而不是某些无意义的字符？比如，如何让R语言知道2004年12日31 小于2022年1月1日 ？如何提取日期序列中的年、月、日？已知我们的数据是日度数据（每月天数不等长），如何求每月的均值，获得月度平均数据？\n我们有两份时间序列数据，它们的日期有交集，但不完全一致，怎样将它们合并起来，以方便我们后续分析？比如，分析股票指数（仅工作日有数据）和汇率（每天都有数据）之间的关系。\n我们怎么对数据进行一些必要的变换？比如取对数，差分等。\n我们怎么筛选出我们需要的数据？比如筛选出2015年至2022年的数据，或筛选出数值为正的数据。\n如何将时间序列可视化，并保存为图片？\n处理好的数据如何导出到硬盘，以供其它用途？\n\n接下来我们逐步解决这些问题。\n\n\n当你希望将硬盘中的数据导入到R语言中时，第一个需要解决的问题就是告诉R语言数据的位置。即，设定工作目录，否则R语言不知道从哪里找到你说的数据，比如某个data.xlsx 文件。\nR语言自带的setwd 函数可以设定工作目录。假定你的数据存放在F:\\mydata\\data 文件夹中，那么你可以通过如下命令设定工作目录：\n\nsetwd(\"F:\\\\mydata\\\\data\") # 注意，是两个\"/\"，即“//”\n\n也可以这样设定工作目录：\n\nsetwd(\"F:/mydata/data\") # 注意，是一个“/”\n\n上述两种办法，大家可以根据自己的偏好使用。\n\n在 R 语言中，可以使用以下函数读取各种格式的数据文件：\n\nCSV 格式：read.csv() 或 read.csv2() 函数可以读取以逗号或分号分隔的文本文件。\nExcel 格式：readxl 包中的 read_excel() 函数可以读取 Excel 文件。\n文本格式：readLines() 函数可以读取文本文件的每一行，read.table() 函数可以读取以空格、制表符或其他分隔符分隔的文本文件。\nJSON 格式：jsonlite 包中的 fromJSON() 函数可以读取 JSON 文件。\nXML 格式：XML 包中的 xmlTreeParse() 或 xmlParse() 函数可以读取 XML 文件。\n数据库格式：RMySQL、RSQLite 和 ROracle 等包提供了连接数据库并读取数据的函数。\nSAS 格式：haven 包中的 read_sas() 函数可以读取 SAS 数据集。\nSPSS 格式：haven 包中的 read_spss() 函数可以读取 SPSS 数据文件。\nStata 格式：haven 包中的 read_dta() 函数可以读取 Stata 数据文件。\n\n是不是眼花缭乱？不同类型的数据文件需要采用不同的函数读取，而这些函数的用法又各不一样，这非常不便于我们进行数据导入。幸运的是，bruceR 包的import 函数为我们整合了很多常见格式的数据文件读取方式。比如，我有一份excel数据文件，后缀为.xlsx ，如下所示：\n\n其中，第一列date 为日期，第二列ER 为汇率（Exchange Rate），数据文件名为02-01人民币对美元汇率.xlsx ，现在使用import 函数将它导入进R语言：\n\nlibrary(bruceR)\n\n\nbruceR (version 0.8.9)\nBRoadly Useful Convenient and Efficient R functions\n\nPackages also loaded:\n√ dplyr         √ emmeans       √ ggplot2\n√ tidyr         √ effectsize    √ ggtext\n√ stringr       √ performance   √ cowplot\n√ forcats       √ lmerTest      √ see\n√ data.table\n\nMain functions of `bruceR`:\ncc()            Describe()  TTEST()\nadd()           Freq()      MANOVA()\n.mean()         Corr()      EMMEANS()\nset.wd()        Alpha()     PROCESS()\nimport()        EFA()       model_summary()\nprint_table()   CFA()       lavaan_summary()\n\nhttps://psychbruce.github.io/bruceR/\n\nNEWS: A new version of bruceR (0.8.10) is available on 2023-03-03!\n***** Please Update *****\ninstall.packages(\"bruceR\", dep=TRUE)\n\nThese R packages are dependencies of `bruceR` but not installed:\npacman, phia, BayesFactor, GGally, GPArotation\n***** Please Install All Dependencies *****\ninstall.packages(\"bruceR\", dep=TRUE)\n\nsetwd(\"F:\\\\学习资料\\\\03. 工作及个人信息相关\\\\青岛大学经济学院\\\\20230223课程-应用时间序列分析\\\\Applied Time Series Analysis\")\ndata <- import(\"02-01人民币对美元汇率.xlsx\")\n\n√ Successfully imported: 8021 obs. of 2 variables\n\n\n上述命令中，我们首先使用library() 函数加载bruceR 包。如果你第一次使用这个包，可能还需要在加载之前安装它，需要使用install.packages(\"bruceR\") 命令（别忘了双引号）。接下来使用setwd() 函数修改工作目录（你可以修改为你自己的工作目录）。最后使用import 函数导入数据，数据文件名记得用\"\" 或'' 括起来。\n结果显示，我们成功导入了上述数据，共8021个观测值，两个变量（即date和ER )。\n\n\n\n\n\n\n\n除.xlsx 格式的数据外，bruceR 包中的import 函数还可以方便地导入很多格式的数据。我们用help 函数查看一些import 函数的帮助文档：\n\nhelp(\"import\")\n\nstarting httpd help server ... done\n\n\n\n可以看到，该函数支持的数据文件类型非常丰富。\n\n我们可以用bruceR 中的export 函数导出数据，基本上可以导出为任何常见的数据格式，下面以.xlsx 格式为例，导出前面的数据：\n\nexport(x = data, file = \"数据导出示例.xlsx\")\n\nOverwrite file \"数据导出示例.xlsx\" ...\n\n\n√ Successfully saved to \"F:/学习资料/03. 工作及个人信息相关/青岛大学经济学院/20230223课程-应用时间序列分析/ATA/数据导出示例.xlsx\"\n\n\n这样，数据就到处到了硬盘中：\n\n\n很简单，如果你需要的话，你也可以导出为其他格式，只需要将数据导出示例.xlsx 的后缀修改即可，比如：\n\ncsv格式：export(x = data, file = \"数据导出示例.csv\")\ndta格式（stata的数据格式）：export(x = data, file = \"数据导出示例.dta\")\ntxt格式：export(x = data, file = \"数据导出示例.txt\")\n……\n\n\n时间序列（或面板数据）中，比较特殊的一列就是时间（或日期）标识，在复杂一些的时间序列数据中，如何处理日期变量可能是一个很重要的问题。比如：\n\n数据库中下载到的数据中，日期变量是”年-月-日”格式，但实际上是年度数据，如何提取其中的年份？\n下载的股票价格日度数据中，每个月的长度（无节假日、周末等）不同，如何求月度均值？\n下载的股票价格日度数据中，如何筛选出月底收盘价数据？\n\n上述这些问题都涉及到对日期变量的处理。\n虽然我们的数据已经导入到R语言中，但第一列的日期变量（date）实际上是字符串格式的，这意味着R语言并不知道这个变量代表的是日期，只知道它是一串字符。我们用str 函数来看一下数据结构：\n\nstr(data)\n\n'data.frame':   8021 obs. of  2 variables:\n $ date: chr  \"1990-12-19\" \"1990-12-20\" \"1990-12-21\" \"1990-12-24\" ...\n $ ER  : num  5.23 5.23 5.23 5.23 5.23 5.23 5.23 5.23 5.23 5.23 ...\n\n\n可以看到，date 变量的数据类型是chr ，也就是字符型。\n如何将date 转化为R语言可以识别的日期格式呢？我推荐使用lubridate 中的系列函数。这些函数无论年月日/时分秒按什么顺序及以什么间隔符分隔，总能正确地识别成日期时间值，举例如下：\n\nlibrary(lubridate)\n\n\nAttaching package: 'lubridate'\n\n\nThe following object is masked from 'package:cowplot':\n\n    stamp\n\n\nThe following objects are masked from 'package:data.table':\n\n    hour, isoweek, mday, minute, month, quarter, second, wday, week,\n    yday, year\n\n\nThe following objects are masked from 'package:base':\n\n    date, intersect, setdiff, union\n\nymd(\"2002-1-4\")\n\n[1] \"2002-01-04\"\n\nymd(\"2002-1~4\")\n\n[1] \"2002-01-04\"\n\nymd(\"2002年1月4日\")\n\n[1] \"2002-01-04\"\n\nmdy(\"01042002\")\n\n[1] \"2002-01-04\"\n\ndmy(\"04012002\")\n\n[1] \"2002-01-04\"\n\nym(\"2002年1月\")\n\n[1] \"2002-01-01\"\n\nmy(\"01~2002\")\n\n[1] \"2002-01-01\"\n\n\n上述示例命令中，以ymd 为例，y 代表year ，即年，m 代表month ，即月 ，d 代表day ，即日 ，也就是说，ymd 函数能够将任意形式的、按照”年-月-日”顺序排列的日期字符串转化为日期格式。类似地，mdy 对应的是”月-日-年”；dmy 对应的是”日-月-年”，ym 则可以转化”年-月”类别的字符串，my 可以转化”月-年”类别的字符串。\n注意data 中的date 是怎么排列的。比如第一行，`1990-12-19` ，是按照年-月-日的顺序排列的。因此，我们需要使用ymd 函数将其转化为日期格式：\n\ndata$date <- ymd(data$date)\n\n#再查看一下数据结构\nstr(data)\n\n'data.frame':   8021 obs. of  2 variables:\n $ date: Date, format: \"1990-12-19\" \"1990-12-20\" ...\n $ ER  : num  5.23 5.23 5.23 5.23 5.23 5.23 5.23 5.23 5.23 5.23 ...\n\n\n可以看到，此时数据data 中的date 变量已经从chr ，即字符串格式转化为了Date ，即日期格式。转化成日期格式后，就可以对日期变量进行一些运算了。比如我们想看一下数据的日期范围，可以使用range 函数：\n\nrange(data$date)\n\n[1] \"1990-12-19\" \"2023-03-03\"\n\n\n其中，range 函数用于求一个向量的最大值和最小值，字符是没有办法比较大小的，但日期和数字可以。所以上述命令可以算出data 中date 变量的最大值和最小值。类似地，我们也可以用它计算一列数的最大值和最小值：\n\nx <- c(1,3,4,5,3,2)\nrange(x)\n\n[1] 1 5\n\n\n\n日度数据求月度平均时，有时候很难根据固定的样本间隔分组。比如，1月份有31天，但2月份可能只有28天。此外，很多时候我们的数据中仅有交易日，而没有周末、节假日等，这就使得每月的实际天数更复杂了。因此，采用等间隔分组求均值的做法是不太现实的。\n我们可以将日期作为分组依据，求得月度平均。怎么做呢？只需要提取出日期变量中的年份和月份信息，然后将相同年份、相同月份的数据作为一组，求均值就可以了。\n为了提取日期变量中的年份和月份，我们可以采用floor_date 函数。比如，它可以将1990-01-02 和1990-01-31 两个日期都转化为当月的最小日期，即1990-01-01 ，如下面的例子所示：\n\nfloor_date(ymd(\"1990-01-02\"), unit = \"month\")\n\n[1] \"1990-01-01\"\n\nfloor_date(ymd(\"1990-01-31\"), unit = \"month\")\n\n[1] \"1990-01-01\"\n\n\n其中，floor 有向下取整的意思，unit = \"month\" 表示以月度为单位向下取整。这样，我们就可以获得关于年和月的信息，然后采用group_by 函数进行分组，并采用summarise 函数计算分组均值：\n\ndata_month <- group_by(data, \n                       year_month = floor_date(date, unit = \"month\"))\ndata_month <- summarise(data_month, ER = mean(ER))\n\nhead(data_month, 20)\n\n# A tibble: 20 × 2\n   year_month    ER\n   <date>     <dbl>\n 1 1990-12-01  5.23\n 2 1991-01-01  5.23\n 3 1991-02-01  5.23\n 4 1991-03-01  5.22\n 5 1991-04-01  5.25\n 6 1991-05-01  5.30\n 7 1991-06-01  5.34\n 8 1991-07-01  5.36\n 9 1991-08-01  5.35\n10 1991-09-01  5.36\n11 1991-10-01  5.38\n12 1991-11-01  5.38\n13 1991-12-01  5.40\n14 1992-01-01  5.43\n15 1992-02-01  5.45\n16 1992-03-01  5.47\n17 1992-04-01  5.49\n18 1992-05-01  5.50\n19 1992-06-01  5.49\n20 1992-07-01  5.47\n\n\n\n按照前面的思路，我们可以先提取出年和月的信息，即前面的year_month ，然后提取出日度的信息，比如day ，然后按照year_month 分组，筛选出每组day 的最大值所在的行，这样就可以提取出每月底的数据了：\n\ndata_month1 <- group_by(data, \n                        year_month = floor_date(date, unit = \"month\"))\ndata_month1$day <- day(data_month1$date)\ndata_month1 <- filter(data_month1, day == max(day))\ndata_month1 <- select(data_month1, year_month, ER)\n\n上面的代码中，第一行和原来相同，第二行采用day 函数从date 变量中提取出了日度 的信息；第三行采用filter 函数选择出了天数等于每月最大值的行，即day == max(day) ，最后一行使用select 函数选择出了我们希望保留的两个变量，即year_month 和ER 。\n\n上述lubridate 包中，对日期序列的处理看起来很复杂（但其实这个包已经非常简洁了）。接下来，我们尝试一些简单的。下面的代码中，我们将计算一个价格序列的对数、差分、简单收益率和对数收益率。\n\n# 创建一个包含股票价格的数据框\ndf <- data.frame(date = c(\"2022-01-01\", \"2022-01-02\", \"2022-01-03\", \"2022-01-04\", \"2022-01-05\"),\n                 price = c(100, 110, 120, 130, 140))\n\n# 添加价格的对数、差分、简单收益率和对数收益率列\ndf <- mutate(df, log_price = log(price),\n         diff_price = price - lag(price),\n         simple_returns = (price - lag(price))/lag(price),\n         log_returns = log(price/lag(price)))\n\n\nprint(df)\n\n        date price log_price diff_price simple_returns log_returns\n1 2022-01-01   100  4.605170         NA             NA          NA\n2 2022-01-02   110  4.700480         10     0.10000000  0.09531018\n3 2022-01-03   120  4.787492         10     0.09090909  0.08701138\n4 2022-01-04   130  4.867534         10     0.08333333  0.08004271\n5 2022-01-05   140  4.941642         10     0.07692308  0.07410797\n\n\n上面的代码中，我们首先使用data.frame 中创建了一个数据框，包含日期date 和价格price 两个变量。\n接下来，我们使用mutate 函数开始生成价格的对数（log_price）、差分（diff_price）、简单收益率（simple_returns）和对数收益率（log_returns）。其中，lag 函数很容易理解，即求价格price 的滞后期，默认求滞后一期；log 函数则是求自然对数。\n\n比如我们要绘制data_month1 中的汇率曲线，可以用ggplot 函数：\n\nggplot(data = data_month1, aes(x = year_month, y = ER)) + geom_line()\n\n\n\n\n上述代码稍微有点特殊，是由一系列函数通过+ 连接起来的，这是ggplot2 特有的绘图风格，即图层叠加。我们可以分步来剖析一下上述代码。\n首先，ggplot 函数中，data = data_month1 告诉我们要对data_month1 中的数据进行绘图，aes(x = year_month, y = ER) 中，x = year_month 是指在将要绘制的图形中，我们让year_month 也就是我们的日期变量作为横轴，y = ER 则是指将ER 也就是汇率，作为纵轴。我们可以单独运行这部分代码来看一下效果：\n\nggplot(data = data_month1, aes(x = year_month, y = ER))\n\n\n\n\n可以看到，上图中已经有了横轴和纵轴，但还没有任何图形。我们可以进一步用+叠加geom_line() 函数，这个函数是指在上面的画布上绘制一条折线图，这样就得到了上面的折线图：\n\nggplot(data = data_month1, aes(x = year_month, y = ER)) + geom_line()\n\n\n\n\n如果你担心别人看不懂横轴和纵轴的标签，你还可以修改它们，只需要叠加使用labs 函数：\n\nggplot(data = data_month1, aes(x = year_month, y = ER)) + \n  geom_line() +\n  labs(x = \"日期\", y = \"中美汇率\")\n\n\n\n\n在此基础上，如果你不喜欢线条的粗细、颜色等，你还可以在geom_line() 函数中通过linewidth 和color 参数修改它们：\n\nggplot(data = data_month1, aes(x = year_month, y = ER)) + \n  geom_line(linewidth = 1, color = \"red\") +\n  labs(x = \"日期\", y = \"中美汇率\")\n\n\n\n\n与ggplot2 绘图相关的知识很多，如果你有更进一步的绘图需求，可以在网上搜索关于它的教程，非常多。\n\n\n我们可以用自相关系数图判断序列的平稳性。随着延迟期数\\(k\\)的增加，平稳时间序列的自相关系数会很快地衰减到零。反之，非平稳之间序列的自相关系数衰减向零的速度通常比较慢，这就是我们利用自相关系数图判断序列平稳性的标准。\n我们可以使用R语言中的基础函数acf 方便地绘制时间序列的自相关系数图。\n\nacf(data_month1$ER, main = \"中美汇率自相关系数图\")\n\n\n\n\n可以看到，随着延迟期数的增大，中美汇率的自相关系数是衰减的，也成为”拖尾”，这说明该序列很可能不是一个平稳的时间序列。\n如果我们想要获得自相关系数的具体数值，只需要将plot 参数设置为FALSE ：\n\nacf(data_month1$ER, plot = FALSE)\n\n\nAutocorrelations of series 'data_month1$ER', by lag\n\n    0     1     2     3     4     5     6     7     8     9    10    11    12 \n1.000 0.982 0.963 0.944 0.924 0.904 0.885 0.866 0.847 0.829 0.811 0.793 0.776 \n   13    14    15    16    17    18    19    20    21    22    23    24    25 \n0.758 0.738 0.719 0.700 0.681 0.662 0.643 0.625 0.606 0.588 0.570 0.551 0.534 \n\n\n在以后的学习中，我们可能还会遇到偏自相关系数，此时我们可以使用pacf 函数绘制：\n\npacf(data_month1$ER, main = \"中美汇率偏自相关系数图\")\n\n\n\n\n在偏自相关系数图中，如果随着延迟期数的增大，偏自相关系数是急剧下降的（又称为”截尾”），就说明该序列很可能是一个非平稳的时间序列。\n\n我们可以使用urca包中的ur.df函数进行时间序列的DF检验和ADF检验。如果你第一次使用这个包，需要使用以下命令安装它：\ninstall.packages(\"urca\")\nur.df 函数主要有三个参数：\n\ny ：即要检验的序列；\ntype ：可以为\"none\" 、\"drift\" 和\"trend\" 三种，分别代表无漂移项且无趋势项、有漂移项、有趋势项三类检验方式；\nlags ：滞后期数，当lags = 0 时，则为DF检验。默认lags = 1 ，是ADF检验。\n\n仍然以中美汇率数据为例，我们首先通过代码进行DF检验。\n\nlibrary(urca)\nur.df(y = data_month1$ER, type = \"none\", lags = 0)\n\n\n############################################################### \n# Augmented Dickey-Fuller Test Unit Root / Cointegration Test # \n############################################################### \n\nThe value of the test statistic is: 0.2422 \n\n\n上述检验给出了统计量的大小，但没有给出显著性水平。为了看到不同显著性水平的临界值，我们可以使用summary 函数对上述结果进行总结：\n\n# 无漂移项、无趋势项的DF检验\nsummary(ur.df(y = data_month1$ER, type = \"none\", lags = 0))\n\n\n############################################### \n# Augmented Dickey-Fuller Test Unit Root Test # \n############################################### \n\nTest regression none \n\n\nCall:\nlm(formula = z.diff ~ z.lag.1 - 1)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.21421 -0.01749 -0.00263 -0.00121  2.88795 \n\nCoefficients:\n         Estimate Std. Error t value Pr(>|t|)\nz.lag.1 0.0002661  0.0010988   0.242    0.809\n\nResidual standard error: 0.1571 on 386 degrees of freedom\nMultiple R-squared:  0.0001519, Adjusted R-squared:  -0.002438 \nF-statistic: 0.05866 on 1 and 386 DF,  p-value: 0.8088\n\n\nValue of test-statistic is: 0.2422 \n\nCritical values for test statistics: \n      1pct  5pct 10pct\ntau1 -2.58 -1.95 -1.62\n\n\n可以看到，DF检验告诉我们，中美汇率序列的DF检验统计量值为0.2422，在10%的临界值（-1.62）的右侧，说明即便在10%的水平上仍不显著。这表明，无趋势项、无漂移项的DF检验认为ER序列是一个非平稳序列。\n类似地，我们还可以进行有漂移项的DF检验，以及有趋势项的DF检验：\n\n# 有漂移项的DF检验\nsummary(ur.df(y = data_month1$ER, type = \"drift\", lags = 0))\n\n\n############################################### \n# Augmented Dickey-Fuller Test Unit Root Test # \n############################################### \n\nTest regression drift \n\n\nCall:\nlm(formula = z.diff ~ z.lag.1 + 1)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.21710 -0.03068 -0.00367  0.01472  2.86044 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)  \n(Intercept)  0.132203   0.058624   2.255   0.0247 *\nz.lag.1     -0.017751   0.008064  -2.201   0.0283 *\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.1563 on 385 degrees of freedom\nMultiple R-squared:  0.01243,   Adjusted R-squared:  0.009865 \nF-statistic: 4.846 on 1 and 385 DF,  p-value: 0.02831\n\n\nValue of test-statistic is: -2.2013 2.5724 \n\nCritical values for test statistics: \n      1pct  5pct 10pct\ntau2 -3.44 -2.87 -2.57\nphi1  6.47  4.61  3.79\n\n\n\n# 有趋势项的DF检验\nsummary(ur.df(y = data_month1$ER, type = \"trend\", lags = 0))\n\n\n############################################### \n# Augmented Dickey-Fuller Test Unit Root Test # \n############################################### \n\nTest regression trend \n\n\nCall:\nlm(formula = z.diff ~ z.lag.1 + 1 + tt)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.19957 -0.02828 -0.00275  0.01087  2.82706 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)   \n(Intercept)  2.061e-01  6.790e-02   3.036  0.00256 **\nz.lag.1     -2.371e-02  8.501e-03  -2.790  0.00554 **\ntt          -1.597e-04  7.498e-05  -2.130  0.03377 * \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.1556 on 384 degrees of freedom\nMultiple R-squared:  0.02397,   Adjusted R-squared:  0.01888 \nF-statistic: 4.714 on 2 and 384 DF,  p-value: 0.00949\n\n\nValue of test-statistic is: -2.7896 3.2436 4.7145 \n\nCritical values for test statistics: \n      1pct  5pct 10pct\ntau3 -3.98 -3.42 -3.13\nphi2  6.15  4.71  4.05\nphi3  8.34  6.30  5.36\n\n\n上述代码中，当我们将lags 参数设置为大于0的整数后，即可变为ADF检验。以滞后期为1为例：\n\n# 无漂移项、无趋势项的ADF检验\nsummary(ur.df(y = data_month1$ER, type = \"none\", lags = 1))\n\n\n############################################### \n# Augmented Dickey-Fuller Test Unit Root Test # \n############################################### \n\nTest regression none \n\n\nCall:\nlm(formula = z.diff ~ z.lag.1 - 1 + z.diff.lag)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.21401 -0.01754 -0.00248 -0.00061  2.88734 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)\nz.lag.1    0.0002375  0.0011022   0.215    0.830\nz.diff.lag 0.0388462  0.0510235   0.761    0.447\n\nResidual standard error: 0.1574 on 384 degrees of freedom\nMultiple R-squared:  0.001659,  Adjusted R-squared:  -0.003541 \nF-statistic: 0.3191 on 2 and 384 DF,  p-value: 0.727\n\n\nValue of test-statistic is: 0.2155 \n\nCritical values for test statistics: \n      1pct  5pct 10pct\ntau1 -2.58 -1.95 -1.62\n\n# 有漂移项的ADF检验\nsummary(ur.df(y = data_month1$ER, type = \"drift\", lags = 1))\n\n\n############################################### \n# Augmented Dickey-Fuller Test Unit Root Test # \n############################################### \n\nTest regression drift \n\n\nCall:\nlm(formula = z.diff ~ z.lag.1 + 1 + z.diff.lag)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.21703 -0.03029 -0.00378  0.01539  2.85889 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)  \n(Intercept)  0.136038   0.059114   2.301   0.0219 *\nz.lag.1     -0.018296   0.008128  -2.251   0.0250 *\nz.diff.lag   0.043931   0.050789   0.865   0.3876  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.1566 on 383 degrees of freedom\nMultiple R-squared:  0.01452,   Adjusted R-squared:  0.009372 \nF-statistic: 2.821 on 2 and 383 DF,  p-value: 0.06078\n\n\nValue of test-statistic is: -2.251 2.6714 \n\nCritical values for test statistics: \n      1pct  5pct 10pct\ntau2 -3.44 -2.87 -2.57\nphi1  6.47  4.61  3.79\n\n# 有趋势项的ADF检验\nsummary(ur.df(y = data_month1$ER, type = \"trend\", lags = 1))\n\n\n############################################### \n# Augmented Dickey-Fuller Test Unit Root Test # \n############################################### \n\nTest regression trend \n\n\nCall:\nlm(formula = z.diff ~ z.lag.1 + 1 + tt + z.diff.lag)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-0.19720 -0.02837 -0.00222  0.01143  2.82474 \n\nCoefficients:\n              Estimate Std. Error t value Pr(>|t|)   \n(Intercept)  2.126e-01  6.888e-02   3.086  0.00218 **\nz.lag.1     -2.453e-02  8.601e-03  -2.853  0.00457 **\ntt          -1.621e-04  7.583e-05  -2.137  0.03321 * \nz.diff.lag   3.847e-02  5.062e-02   0.760  0.44772   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.1558 on 382 degrees of freedom\nMultiple R-squared:  0.02616,   Adjusted R-squared:  0.01852 \nF-statistic: 3.421 on 3 and 382 DF,  p-value: 0.01741\n\n\nValue of test-statistic is: -2.8526 3.3202 4.8413 \n\nCritical values for test statistics: \n      1pct  5pct 10pct\ntau3 -3.98 -3.42 -3.13\nphi2  6.15  4.71  4.05\nphi3  8.34  6.30  5.36\n\n\n\n我们学习过两种纯随机性检验的统计量，即\\(Q_{BP}\\)统计量和\\(Q_{LB}\\)统计量。他们的原假设和备择假设为：\n原假设：延迟期数小于或等于 $m$ 期的序列值之间相互独立。\n备择假设：延迟期数小于或等于 \\(m\\) 期的序列值之间有相关性。\n该假设条件用数学语言描述为:\n\\[\n\\begin{aligned}& H_0: \\rho_1=\\rho_2=\\cdots=\\rho_m=0, \\forall m \\geqslant 1 \\\\& H_1: \\text { 至少存在某个 } \\rho_k \\neq 0, \\forall m \\geqslant 1, k \\leqslant m\\end{aligned}\n\\]\n其中，\\(Q_{BP}\\)统计量的构造为：\n\\[\nQ=n \\sum_{k=1}^m \\hat{\\rho}_k^2\n\\]\n\\(Q_{LB}\\)统计量的构造为：\n\\[\n\\mathrm{LB}=n(n+2) \\sum_{k=1}^m\\left(\\frac{\\hat{\\rho}_k^2}{n-k}\\right)\n\\]\n我们可以使用Box.test 函数进行纯随机性检验，该函数是R语言的一个基础函数，它有三个参数：\n\nx ：即要检验的变量名称；\ntype ：统计量类型，包括Box-Pierce 和Ljung-Box ，分别对应\\(Q_{BP}\\)和\\(Q_{LB}\\)两个统计量；\nlag ：要检验的滞后期数，即上述原假设中的\\(m\\)。\n\n\n# BP检验\nBox.test(data_month1$ER, type = \"Box-Pierce\", lag = 6)\n\n\n    Box-Pierce test\n\ndata:  data_month1$ER\nX-squared = 2031.7, df = 6, p-value < 2.2e-16\n\n\n\n# LB检验\nBox.test(data_month1$ER, type = \"Ljung-Box\", lag = 6)\n\n\n    Box-Ljung test\n\ndata:  data_month1$ER\nX-squared = 2060.2, df = 6, p-value < 2.2e-16\n\n\n可以看到，上述两个统计量对应的伴随概率都远小于0.1，其中e-16 的意识是10的负16次方，说明拒绝上述原假设，即至少有一个自相关系数不为零，即该序列不是一个纯随机序列。\n接下来我们模拟一组正态分布随机数再试一下：\n\nset.seed(1) # 设定随机数种子，以保证结果可重复\nx <- rnorm(100)\n\nBox.test(x = x, type = \"Box-Pierce\", lag = 6)\n\n\n    Box-Pierce test\n\ndata:  x\nX-squared = 4.921, df = 6, p-value = 0.554\n\nBox.test(x = x, type = \"Ljung-Box\", lag = 6)\n\n\n    Box-Ljung test\n\ndata:  x\nX-squared = 5.2592, df = 6, p-value = 0.511\n\n\n可以看到，生成的随机数x ，两个统计量都接受了原假设（概率值远大于0.05或0.1），说明该序列可以认为是一个纯随机序列。"
  }
]